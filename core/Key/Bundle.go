package Key

import (
  "crypto/sha256"
  "io"
)

// BundleKey is an alias of 32-byte array
type BundleKey [32]byte

// BundlePrivate holds private parts of identity key, signed pre-key and one-time pre-keys.
type BundlePrivate struct {
  Identity Private
  Spk Private
  PreKeys map[BundleKey]Private
}

// BundlePublic holds public parts of identity key, signed pre-key and one-time pre-keys.
type BundlePublic struct {
  Identity Public
  Spk SignedPreKeyPublic
  PreKeys map[BundleKey]Public
}

// Both private and public bundles also bundled together
type Bundle struct {
  Private BundlePrivate
  Public BundlePublic
}

// Creates a new bundle using specified random number generator
func NewBundle(random io.Reader) (*Bundle, error) {
  id, err := Generate(random)

  if err != nil {
    return nil, err
  }

  spk, err := NewSignedPreKey(id.PrivateKey)

  if err != nil {
    return nil, err
  }

  priv := BundlePrivate{
    Identity: id.PrivateKey,
    Spk: spk.PrivateKey,
  }

  pub := BundlePublic {
    Identity: id.PublicKey,
    Spk: spk.Public,
  }

  bundle := Bundle{
    Private: priv,
    Public: pub,
  }

  return &bundle, nil
}

// Performs equality comparison with other public bundle
func (b *BundlePublic) PublicBundleEquals(other *BundlePublic) bool {
  return b.Identity.PublicKeyEquals(&other.Identity)
}

// Populate a number one-time pre-keys with specified with `size` 
func (b *Bundle) PopulatePreKeys(random io.Reader, size int) {

  b.Private.PreKeys = make(map[BundleKey]Private)
  b.Public.PreKeys = make(map[BundleKey]Public)
  for i := 0; i < size; i ++ {
    p, err := Generate(random)
    if err == nil {
      h := sha256.Sum256(p.PublicKey[:])

      b.Private.PreKeys[h] = p.PrivateKey
      b.Public.PreKeys[h] = p.PublicKey
    }
  }
}

// Pops a pre-key from the list of of pre-keys generated by 
// PopulatePreKeys function. The key no longer available once it is popped out.
// This returns both the pre-key id and the public part of the pre-key
func (b *BundlePublic) PopPreKey() ([32]byte, *Public) {
  var empty [32]byte
  if len(b.PreKeys) == 0 {
    return empty, nil
  }

  for k := range b.PreKeys {
    popped := b.PreKeys[k]
    delete(b.PreKeys, k)
    return k, &popped
  }
  return empty, nil
}

// Verify the bundle using it's signed pre-key and identity keys
func (b *BundlePublic) Verify() bool {
  return b.Spk.Verify(b.Identity);
}

// Fetches a pre-key from the one-time pre-keys list based on the id.
func (b *BundlePrivate) FetchPreKey(id [32]byte) *Private {
  if len(b.PreKeys) == 0 {
    return nil
  }

  ret, ok := b.PreKeys[id]
  if ok {
    delete(b.PreKeys, id)
    return &ret
  }
  return nil
}


